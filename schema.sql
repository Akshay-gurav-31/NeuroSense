-- NeuroSense Production Database Schema
-- Single Source of Truth

-- 1. Users Table (Core Registry)
CREATE TABLE IF NOT EXISTS users (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL,
    password TEXT NOT NULL,
    role TEXT NOT NULL CHECK (role IN ('PATIENT', 'DOCTOR')),
    phone TEXT,
    avatar_url TEXT,
    start_date TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- SAFETY: Ensure new columns exist even if table was already created
DO $$
BEGIN
    ALTER TABLE users ADD COLUMN IF NOT EXISTS phone TEXT;
    ALTER TABLE users ADD COLUMN IF NOT EXISTS avatar_url TEXT;
    ALTER TABLE users ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP;
EXCEPTION
    WHEN duplicate_column THEN RAISE NOTICE 'Column already exists in users.';
END $$;

-- 2. New Profile Tables (Separated by Role)
CREATE TABLE IF NOT EXISTS patient_profiles (
    user_id TEXT PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    diagnosis TEXT,
    case_id TEXT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS doctor_profiles (
    user_id TEXT PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    license_id TEXT,
    is_verified BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- 3. Sessions & Connections
CREATE TABLE IF NOT EXISTS sessions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    patient_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    type TEXT NOT NULL CHECK (type IN ('BODY', 'BRAIN', 'SPEECH', 'MENTAL')),
    score INTEGER NOT NULL CHECK (score BETWEEN 0 AND 100),
    feedback TEXT
);

CREATE TABLE IF NOT EXISTS connections (
    id TEXT PRIMARY KEY,
    patient_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    doctor_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    status TEXT NOT NULL CHECK (status IN ('IDLE', 'PENDING', 'CONNECTED')),
    timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    UNIQUE(patient_id, doctor_id)
);

-- 4. AUTO-MIGRATION LOGIC (Preserves Data)
-- This block moves data from the old 'profiles' table if it exists
DO $$
BEGIN
    IF EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'profiles') THEN
        -- Migrate Patients
        INSERT INTO patient_profiles (user_id, diagnosis, case_id)
        SELECT user_id, diagnosis, case_id FROM profiles
        WHERE diagnosis IS NOT NULL OR case_id IS NOT NULL
        ON CONFLICT (user_id) DO NOTHING;

        -- Migrate Doctors
        INSERT INTO doctor_profiles (user_id, license_id, is_verified)
        SELECT user_id, license_id, is_verified FROM profiles
        WHERE license_id IS NOT NULL
        ON CONFLICT (user_id) DO NOTHING;
    END IF;
END $$;

-- 5. CLEANUP (Drop old table after migration)
-- Only run this if you are sure migration succeeded. 
-- Uncomment the next line to enable auto-deletion of the old table.
-- DROP TABLE IF EXISTS profiles;

-- 6. Row-Level Security (RLS) policies
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE patient_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE doctor_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE connections ENABLE ROW LEVEL SECURITY;

-- Policy Definitions (Simplified for Production)
-- Users
DROP POLICY IF EXISTS "Public registration" ON users;
CREATE POLICY "Public registration" ON users FOR INSERT WITH CHECK (true);

DROP POLICY IF EXISTS "User read own" ON users;
CREATE POLICY "User read own" ON users FOR SELECT USING (true);

DROP POLICY IF EXISTS "User update own" ON users;
CREATE POLICY "User update own" ON users FOR UPDATE USING (true);

-- Patient Profiles
DROP POLICY IF EXISTS "Patient create profile" ON patient_profiles;
CREATE POLICY "Patient create profile" ON patient_profiles FOR INSERT WITH CHECK (true);

DROP POLICY IF EXISTS "Read patient profiles" ON patient_profiles;
CREATE POLICY "Read patient profiles" ON patient_profiles FOR SELECT USING (true);

DROP POLICY IF EXISTS "Patient update own" ON patient_profiles;
CREATE POLICY "Patient update own" ON patient_profiles FOR UPDATE USING (true);

-- Doctor Profiles
DROP POLICY IF EXISTS "Doctor create profile" ON doctor_profiles;
CREATE POLICY "Doctor create profile" ON doctor_profiles FOR INSERT WITH CHECK (true);

DROP POLICY IF EXISTS "Read doctor profiles" ON doctor_profiles;
CREATE POLICY "Read doctor profiles" ON doctor_profiles FOR SELECT USING (true);

DROP POLICY IF EXISTS "Doctor update own" ON doctor_profiles;
CREATE POLICY "Doctor update own" ON doctor_profiles FOR UPDATE USING (true);

-- Sessions & Connections
DROP POLICY IF EXISTS "Session insert" ON sessions;
CREATE POLICY "Session insert" ON sessions FOR INSERT WITH CHECK (true);

DROP POLICY IF EXISTS "Session read" ON sessions;
CREATE POLICY "Session read" ON sessions FOR SELECT USING (true);

DROP POLICY IF EXISTS "Connection insert" ON connections;
CREATE POLICY "Connection insert" ON connections FOR INSERT WITH CHECK (true);

DROP POLICY IF EXISTS "Connection read" ON connections;
CREATE POLICY "Connection read" ON connections FOR SELECT USING (true);

DROP POLICY IF EXISTS "Connection update" ON connections;
CREATE POLICY "Connection update" ON connections FOR UPDATE USING (true);

-- 7. Realtime Triggers for updated_at
CREATE OR REPLACE FUNCTION update_timestamp() RETURNS TRIGGER AS $$
BEGIN
   NEW.updated_at = NOW();
   RETURN NEW;
END;
$$ language 'plpgsql';

DROP TRIGGER IF EXISTS update_users_timestamp ON users;
CREATE TRIGGER update_users_timestamp BEFORE UPDATE ON users FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

DROP TRIGGER IF EXISTS update_patients_timestamp ON patient_profiles;
CREATE TRIGGER update_patients_timestamp BEFORE UPDATE ON patient_profiles FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

DROP TRIGGER IF EXISTS update_doctors_timestamp ON doctor_profiles;
CREATE TRIGGER update_doctors_timestamp BEFORE UPDATE ON doctor_profiles FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


-- 8. STORAGE CONFIGURATION (Avatars)
-- Create a public bucket for profile images
INSERT INTO storage.buckets (id, name, public) 
VALUES ('avatars', 'avatars', true)
ON CONFLICT (id) DO NOTHING;

-- Storage Security Policies
-- Allow public access to view avatars
DROP POLICY IF EXISTS "Avatar images are publicly accessible" ON storage.objects;
CREATE POLICY "Avatar images are publicly accessible"
  ON storage.objects FOR SELECT
  USING ( bucket_id = 'avatars' );

-- Allow authenticated users to upload avatars
DROP POLICY IF EXISTS "Anyone can upload an avatar" ON storage.objects;
CREATE POLICY "Anyone can upload an avatar"
  ON storage.objects FOR INSERT
  WITH CHECK ( bucket_id = 'avatars' );

-- Allow users to update their own avatars (optional, depends on file naming strategy)
DROP POLICY IF EXISTS "Users can update own avatar" ON storage.objects;
CREATE POLICY "Users can update own avatar"
  ON storage.objects FOR UPDATE
  USING ( bucket_id = 'avatars' );
-- 7. DATA SEEDING / MIGRATION FIXES
-- Ensure all existing doctors have profiles and are verified
INSERT INTO doctor_profiles (user_id, is_verified)
SELECT id, TRUE
FROM users
WHERE role = 'DOCTOR'
ON CONFLICT (user_id) DO UPDATE SET is_verified = TRUE;
